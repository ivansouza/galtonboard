<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    
    <!-- Cache Control: Force browser to reload -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Galton Board 3D - Dark Edition</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            /* Dark Ocean background */
            background: linear-gradient(160deg, #0f2027 0%, #203a43 50%, #2c5364 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
        }
        
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            box-sizing: border-box;
            z-index: 10;
        }

        /* --- SLIDE CONTROLS --- */
        #settings-panel {
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(8px);
            padding: 10px 20px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            gap: 20px;
            margin-bottom: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .setting-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .setting-label {
            font-size: 11px;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.7);
            text-transform: uppercase;
            margin-bottom: 4px;
            display: flex;
            justify-content: space-between;
            width: 100%;
        }
        
        .setting-value { color: #fff; font-weight: 800; margin-left: 5px; }

        input[type=range] {
            -webkit-appearance: none;
            width: 120px;
            height: 4px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
            outline: none;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }

        /* --- HEADER AND CONTROLS --- */
        #header {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 25px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            backdrop-filter: blur(12px);
            text-align: center;
            pointer-events: auto;
            border: 1px solid rgba(255,255,255,0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            color: rgba(255,255,255,0.9);
            font-size: 10px;
            font-weight: 800;
            letter-spacing: 2px;
            text-transform: uppercase;
            margin: 0 0 5px 0;
        }

        #counter {
            font-size: 32px;
            font-weight: 300;
            color: #ffffff;
            font-variant-numeric: tabular-nums;
            line-height: 1;
            margin-bottom: 8px;
            text-shadow: 0 2px 10px rgba(0,0,0,0.5);
        }

        #controls {
            display: flex;
            gap: 8px;
        }

        .btn {
            background: rgba(255,255,255,0.9);
            color: #222;
            border: none;
            padding: 8px 20px;
            font-size: 12px;
            border-radius: 50px;
            cursor: pointer;
            text-transform: uppercase;
            font-weight: 700;
            letter-spacing: 0.5px;
            transition: all 0.2s;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        .btn:hover { transform: translateY(-1px); background: #fff; box-shadow: 0 6px 15px rgba(255,255,255,0.3); }
        .btn:active { transform: scale(0.95); }
        .btn:disabled { background: rgba(255,255,255,0.3); color: #555; cursor: default; transform: none; box-shadow: none; }

        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(30, 40, 50, 0.9);
            padding: 20px 40px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            font-weight: 600;
            color: #fff;
            transition: opacity 0.5s;
            z-index: 50;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.1);
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="loading">Preparing simulation...</div>

    <div id="ui-layer">
        
        <div id="settings-panel">
            <div class="setting-group">
                <div class="setting-label">Balls <span id="val-balls" class="setting-value">500</span></div>
                <input type="range" id="slide-balls" min="100" max="1500" step="50" value="500">
            </div>
            <div class="setting-group">
                <div class="setting-label">Speed <span id="val-speed" class="setting-value">20</span></div>
                <input type="range" id="slide-speed" min="1" max="50" step="1" value="20">
            </div>
        </div>

        <div id="header">
            <h1>Galton Board 3D</h1>
            <div id="counter">0</div>
            <div id="controls">
                <button id="btn-start" class="btn">Launch</button>
                <button id="btn-reset" class="btn">Reset</button>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';

        // --- CONFIG ---
        const CONFIG = {
            count: 500,         
            spawnRate: 20,      
            rows: 14,
            spacing: 2.8,
            ballRadius: 0.32,
            pegRadius: 0.18,
            boardDepth: 1.5,
            gravity: 0.25,
            friction: 0.96,
            bounce: 0.5,
        };

        let scene, camera, renderer, controls;
        let ballMesh, dummy = new THREE.Object3D(), matrix = new THREE.Matrix4();
        let balls = [], bins = [];
        let activeCount = 0, stoppedCount = 0, isRunning = false;
        
        let startY, binY, binOriginX, ballsPerBinRow = 4;

        // UI Elements
        const elCounter = document.getElementById('counter');
        const btnStart = document.getElementById('btn-start');
        const btnReset = document.getElementById('btn-reset');
        const elLoading = document.getElementById('loading');
        
        const slideBalls = document.getElementById('slide-balls');
        const valBalls = document.getElementById('val-balls');
        const slideSpeed = document.getElementById('slide-speed');
        const valSpeed = document.getElementById('val-speed');

        init();
        animate();

        function init() {
            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 110); 

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;
            controls.maxPolarAngle = Math.PI / 1.8;
            controls.minDistance = 50;
            controls.maxDistance = 200;

            setupLighting();
            buildBoard();
            initBalls();

            elLoading.style.opacity = 0;
            setTimeout(() => elLoading.style.display = 'none', 500);

            // Events
            btnStart.addEventListener('click', () => {
                if(stoppedCount >= CONFIG.count) resetSim();
                isRunning = true;
                btnStart.disabled = true;
                slideBalls.disabled = true;
            });

            btnReset.addEventListener('click', () => {
                resetSim();
                slideBalls.disabled = false;
            });
            
            // Slider Logic
            slideSpeed.addEventListener('input', (e) => {
                CONFIG.spawnRate = parseInt(e.target.value);
                valSpeed.innerText = CONFIG.spawnRate;
            });

            slideBalls.addEventListener('change', (e) => {
                const newVal = parseInt(e.target.value);
                CONFIG.count = newVal;
                valBalls.innerText = newVal;
                scene.remove(ballMesh);
                balls = [];
                initBalls();
                resetSim();
            });
            slideBalls.addEventListener('input', (e) => {
                 valBalls.innerText = e.target.value;
            });

            window.addEventListener('resize', onResize);
        }

        function setupLighting() {
            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambient);

            const mainLight = new THREE.DirectionalLight(0xffffff, 1.2);
            mainLight.position.set(20, 50, 40);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            scene.add(mainLight);

            // Backlight for glass
            const backLight = new THREE.SpotLight(0xffffff, 5.0);
            backLight.position.set(0, 20, -60);
            backLight.lookAt(0, 0, 0);
            backLight.angle = Math.PI / 4;
            backLight.penumbra = 1;
            scene.add(backLight);

            const rimLight = new THREE.PointLight(0xaaccff, 1.5);
            rimLight.position.set(-50, 0, 0);
            scene.add(rimLight);
        }

        function buildBoard() {
            const triangleH = CONFIG.rows * (CONFIG.spacing * 0.866);
            const boardW = (CONFIG.rows + 6) * CONFIG.spacing;
            
            startY = triangleH / 2 + 5;
            binY = -triangleH / 2 - 5;
            
            const laneHeight = 35;
            const laneYCenter = binY - (laneHeight / 2);
            
            const boxTopY = startY + 8;
            const boxBottomY = binY - laneHeight;
            const totalBoxHeight = boxTopY - boxBottomY;
            const boxCenterY = (boxTopY + boxBottomY) / 2;
            const boxDepth = CONFIG.boardDepth + 0.5; 

            // Glass Case Material
            const caseMat = new THREE.MeshPhysicalMaterial({ 
                color: 0xffffff,
                transmission: 0.98,
                opacity: 1,
                roughness: 0.05,
                metalness: 0.1,
                ior: 1.5,
                thickness: 2.0,
                clearcoat: 1.0,
                side: THREE.DoubleSide
            });

            // 1. BACK PLATE
            const backGeo = new RoundedBoxGeometry(boardW, totalBoxHeight, 0.3, 4, 1);
            const backPlate = new THREE.Mesh(backGeo, caseMat);
            backPlate.position.set(0, boxCenterY, -boxDepth/2);
            backPlate.receiveShadow = true;
            scene.add(backPlate);

            // 2. FRONT PLATE
            const frontGeo = new RoundedBoxGeometry(boardW, totalBoxHeight, 0.1, 4, 1);
            const frontPlate = new THREE.Mesh(frontGeo, caseMat);
            frontPlate.position.set(0, boxCenterY, boxDepth/2);
            scene.add(frontPlate);

            // 3. SIDE WALLS
            const sideWallThick = 0.5;
            const sideGeo = new THREE.BoxGeometry(sideWallThick, totalBoxHeight, boxDepth);
            
            const leftWall = new THREE.Mesh(sideGeo, caseMat);
            leftWall.position.set(-boardW/2 + sideWallThick/2, boxCenterY, 0);
            scene.add(leftWall);

            const rightWall = new THREE.Mesh(sideGeo, caseMat);
            rightWall.position.set(boardW/2 - sideWallThick/2, boxCenterY, 0);
            scene.add(rightWall);

            // 4. TOP & BOTTOM WALLS
            const capGeo = new THREE.BoxGeometry(boardW, sideWallThick, boxDepth);
            
            const topWall = new THREE.Mesh(capGeo, caseMat);
            topWall.position.set(0, boxTopY - sideWallThick/2, 0);
            scene.add(topWall);

            const bottomWall = new THREE.Mesh(capGeo, caseMat);
            bottomWall.position.set(0, boxBottomY + sideWallThick/2, 0);
            scene.add(bottomWall);

            // --- INTERNAL ELEMENTS ---

            // Pegs
            const pegGeo = new THREE.CylinderGeometry(CONFIG.pegRadius, CONFIG.pegRadius, CONFIG.boardDepth - 0.2, 16);
            pegGeo.rotateX(Math.PI/2);
            const pegMat = new THREE.MeshStandardMaterial({ 
                color: 0x222222, 
                roughness: 0.4, 
                metalness: 0.5 
            });
            const pegInst = new THREE.InstancedMesh(pegGeo, pegMat, 400);
            
            let idx = 0;
            for(let r=0; r<CONFIG.rows; r++) {
                const pins = r + 1;
                const rowWidth = (pins-1)*CONFIG.spacing;
                const rx = -rowWidth/2;
                const ry = startY - r*(CONFIG.spacing*0.866);
                
                for(let c=0; c<pins; c++) {
                    const px = rx + c*CONFIG.spacing;
                    dummy.position.set(px, ry, 0);
                    dummy.updateMatrix();
                    pegInst.setMatrixAt(idx++, dummy.matrix);
                }
            }
            pegInst.receiveShadow = true;
            pegInst.castShadow = true;
            scene.add(pegInst);

            // --- Lanes (Dividers) - FINE WOOD ---
            const numBins = CONFIG.rows + 1;
            bins = new Array(numBins).fill(0);
            
            const lastRowW = (CONFIG.rows - 1) * CONFIG.spacing;
            const lastRowStart = -lastRowW / 2;
            binOriginX = lastRowStart - CONFIG.spacing; 

            // Capacity
            const innerWidth = CONFIG.spacing - 0.3; 
            ballsPerBinRow = Math.floor(innerWidth / (CONFIG.ballRadius * 2));
            if(ballsPerBinRow < 1) ballsPerBinRow = 1;

            const divGeo = new THREE.BoxGeometry(0.15, laneHeight, CONFIG.boardDepth - 0.2);
            
            // WOOD MATERIAL
            const woodMat = new THREE.MeshStandardMaterial({ 
                color: 0x8B5A2B,  // SaddleBrown
                roughness: 0.8,
                metalness: 0.0,
                flatShading: false
            });

            const divInst = new THREE.InstancedMesh(divGeo, woodMat, numBins + 1);
            
            for(let i=0; i<=numBins; i++) {
                const x = (lastRowStart - CONFIG.spacing) + i*CONFIG.spacing;
                dummy.position.set(x, binY - (laneHeight/2), 0); 
                dummy.updateMatrix();
                divInst.setMatrixAt(i, dummy.matrix);
            }
            divInst.castShadow = true;
            divInst.receiveShadow = true;
            scene.add(divInst);

            // Curve (SOLID GOLD)
            drawCurve(numBins, laneHeight);
        }

        function drawCurve(numBins, laneHeight) {
            const points = [];
            const sigma = Math.sqrt(CONFIG.rows) * CONFIG.spacing * 0.55; 
            const scaleH = 11; 
            const range = (numBins * CONFIG.spacing) / 2 + 2;

            for(let x = -range; x <= range; x += 0.5) { 
                const y = Math.exp(-(x*x)/(2*sigma*sigma)) * scaleH;
                points.push(new THREE.Vector3(x, (binY - laneHeight) + y, -CONFIG.boardDepth/2 + 0.1));
            }
            
            // Tube for solid effect
            const curvePath = new THREE.CatmullRomCurve3(points);
            const tubeGeo = new THREE.TubeGeometry(curvePath, 64, 0.15, 8, false);
            
            // GOLD MATERIAL
            const goldMat = new THREE.MeshStandardMaterial({ 
                color: 0xFFD700, 
                metalness: 1.0, 
                roughness: 0.2,
                emissive: 0x221100
            });
            
            const curveMesh = new THREE.Mesh(tubeGeo, goldMat);
            scene.add(curveMesh);
        }

        function initBalls() {
            const geo = new THREE.SphereGeometry(CONFIG.ballRadius, 16, 16);
            const mat = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                metalness: 0.9,
                roughness: 0.1,
            });

            ballMesh = new THREE.InstancedMesh(geo, mat, CONFIG.count);
            ballMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            ballMesh.castShadow = true;
            ballMesh.receiveShadow = true;
            ballMesh.frustumCulled = false; 
            scene.add(ballMesh);

            for(let i=0; i<CONFIG.count; i++) {
                balls.push({ x: 0, y: 100, z: 0, vx: 0, vy: 0, active: false, stopped: false });
                matrix.setPosition(0, 100, 0);
                ballMesh.setMatrixAt(i, matrix);
            }
        }

        function resetSim() {
            isRunning = false;
            activeCount = 0;
            stoppedCount = 0;
            bins.fill(0);
            elCounter.innerText = "0";

            for(let i=0; i<CONFIG.count; i++) {
                balls[i].active = false;
                balls[i].stopped = false;
                balls[i].y = 100;
                matrix.setPosition(0, 100, 0);
                ballMesh.setMatrixAt(i, matrix);
            }
            ballMesh.instanceMatrix.needsUpdate = true;
            btnStart.disabled = false;
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function update() {
            if(!isRunning) return;

            if(activeCount < CONFIG.count) {
                const batch = Math.min(CONFIG.spawnRate, CONFIG.count - activeCount);
                for(let k=0; k<batch; k++) {
                    const b = balls[activeCount++];
                    b.active = true;
                    b.stopped = false;
                    b.y = startY + 2 + Math.random()*2;
                    b.x = (Math.random()-0.5) * 0.1;
                    b.z = (Math.random()-0.5) * (CONFIG.boardDepth - CONFIG.ballRadius*2.2);
                    b.vx = (Math.random()-0.5) * 0.05;
                    b.vy = 0;
                }
            }

            const pinTop = startY + 1;
            const pinBottom = startY - (CONFIG.rows * CONFIG.spacing * 0.866) - 1;
            const zLim = CONFIG.boardDepth/2 - CONFIG.ballRadius;
            const laneHeight = 35; 

            for(let i=0; i<activeCount; i++) {
                const b = balls[i];
                if(b.stopped) continue;

                b.vy -= CONFIG.gravity;
                b.vx *= CONFIG.friction;
                b.x += b.vx;
                b.y += b.vy;

                if(b.z > zLim) { b.z = zLim; b.vz *= -0.5; }
                else if(b.z < -zLim) { b.z = -zLim; b.vz *= -0.5; }

                if(b.y < pinTop && b.y > pinBottom) {
                    const rApprox = Math.round((startY - b.y) / (CONFIG.spacing * 0.866));
                    if(rApprox >= 0 && rApprox < CONFIG.rows) {
                        const pins = rApprox + 1;
                        const rowWidth = (pins-1)*CONFIG.spacing;
                        const rx = -rowWidth/2;
                        const cApprox = Math.round((b.x - rx) / CONFIG.spacing);
                        
                        if(cApprox >= 0 && cApprox < pins) {
                            const px = rx + cApprox*CONFIG.spacing;
                            const py = startY - rApprox*(CONFIG.spacing*0.866);
                            const dx = b.x - px;
                            const dy = b.y - py;
                            const dSq = dx*dx + dy*dy;
                            const minDist = CONFIG.pegRadius + CONFIG.ballRadius;
                            
                            if(dSq < minDist*minDist) {
                                const d = Math.sqrt(dSq);
                                const nx = dx/d;
                                const ny = dy/d;
                                
                                const pen = minDist - d;
                                b.x += nx * pen;
                                b.y += ny * pen;
                                
                                b.vx += nx * 0.2; 
                                b.vy *= -CONFIG.bounce;
                                
                                if(Math.abs(dx) < 0.01) b.vx += (Math.random()-0.5)*0.15;
                            }
                        }
                    }
                }
                else if(b.y < pinBottom) {
                    let binIdx = Math.floor((b.x - binOriginX) / CONFIG.spacing);
                    
                    if(binIdx < 0) binIdx = 0;
                    if(binIdx >= bins.length) binIdx = bins.length - 1;
                    
                    const count = bins[binIdx];
                    const col = count % ballsPerBinRow;
                    const row = Math.floor(count / ballsPerBinRow);
                    
                    const binLeftX = binOriginX + binIdx*CONFIG.spacing;
                    const totalW = ballsPerBinRow * (CONFIG.ballRadius * 2);
                    const margin = (CONFIG.spacing - totalW) / 2;
                    
                    const targetX = binLeftX + margin + col * (CONFIG.ballRadius * 2) + CONFIG.ballRadius;
                    const targetY = (binY - laneHeight) + CONFIG.ballRadius + row * (CONFIG.ballRadius * 2);
                    
                    b.vx += (targetX - b.x) * 0.25; 
                    b.vx *= 0.5;

                    if(b.y <= targetY) {
                        b.x = targetX;
                        b.y = targetY;
                        b.stopped = true;
                        bins[binIdx]++;
                        stoppedCount++;
                        elCounter.innerText = stoppedCount;
                    }
                }
                
                matrix.setPosition(b.x, b.y, b.z);
                ballMesh.setMatrixAt(i, matrix);
            }
            ballMesh.instanceMatrix.needsUpdate = true;

            if(stoppedCount >= CONFIG.count) {
                isRunning = false;
                btnStart.disabled = false;
                slideBalls.disabled = false;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>

